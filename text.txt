<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Ann Arbor Streets List</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />
  <style>
    html,
    body,
    #map {
      height: 40vh;
      margin: 0;
      padding: 0;
    }
    #list {
      height: 55vh;
      overflow-y: auto;
      padding: 10px;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto,
        "Helvetica Neue", Arial;
      background: #fafafa;
      border-top: 1px solid #ccc;
    }
    #loading {
      padding: 10px;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto,
        "Helvetica Neue", Arial;
      color: #555;
    }
    h2 {
      margin: 5px 0;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="loading">Loading Ann Arbor city boundary and streets...</div>
  <div id="list"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    // Overpass API endpoint
    const OVERPASS_URL = "https://overpass-api.de/api/interpreter";

    // Function to fetch JSON from Overpass API with given query
    async function overpassQuery(query) {
      const response = await fetch(OVERPASS_URL, {
        method: "POST",
        body: query,
        headers: { "Content-Type": "text/plain" },
      });
      if (!response.ok) throw new Error("Overpass API error");
      return response.json();
    }

    // Step 1: Fetch Ann Arbor city boundary polygon (relation with name=Ann Arbor and admin_level=8)
    const boundaryQuery = `
      [out:json][timeout:25];
      relation["boundary"="administrative"]["admin_level"="8"]["name"="Ann Arbor"]->.rel;
      (.rel;>;);
      out body;
    `;

    // Globals
    let cityPolygonLatLngs = [];
    let map;
    let cityBoundaryLayer;

    // Utility: Convert OSM geometry to Leaflet LatLng arrays
    function osmGeometryToLatLngs(elements) {
      const nodes = {};
      elements
        .filter((e) => e.type === "node")
        .forEach((n) => {
          nodes[n.id] = [n.lat, n.lon];
        });

      // A relation's geometry is in its member ways
      // We'll build polygons from member ways, sorted by sequence
      const ways = elements.filter((e) => e.type === "way");

      // Each way is an array of node ids forming a polyline
      // Build an array of latlng arrays for each way
      return ways.map((way) => way.geometry.map((p) => [p.lat, p.lon]));
    }

    // Step 2: Use polygon to fetch all streets fully inside it (highway ways with name)
    function buildPolygonString(latlngs) {
      // Format: lat lon pairs separated by spaces, polygon string for Overpass
      return latlngs.map((ll) => ll[0] + " " + ll[1]).join(" ");
    }

    // Because Ann Arbor relation geometry comes as multiple ways forming the boundary,
    // we need to stitch these together into a single polygon.
    // For simplicity, we’ll just flatten all ways into one long polygon.
    // This might not be perfect for complex boundaries but is fine here.

    // Function to flatten multi-line polygon geometry into a simple polygon (may self-intersect)
    function flattenPolygon(waysLatLngs) {
      let flat = [];
      waysLatLngs.forEach((way) => {
        flat.push(...way);
      });
      // Close polygon if needed
      if (
        flat.length &&
        (flat[0][0] !== flat[flat.length - 1][0] ||
          flat[0][1] !== flat[flat.length - 1][1])
      ) {
        flat.push(flat[0]);
      }
      return flat;
    }

    // Normalize street name (remove abbreviations and punctuation)
    function normalizeName(s) {
      if (!s) return "";
      s = s.toLowerCase().trim();
      s = s.replace(/[.,'"]/g, "");
      // Expand common abbreviations (St, Rd, Ave, Blvd, Dr, Ln, Ct, Pkwy)
      s = s.replace(/\bst\.?$/, "street");
      s = s.replace(/\brd\.?$/, "road");
      s = s.replace(/\bave\.?$/, "avenue");
      s = s.replace(/\bblvd\.?$/, "boulevard");
      s = s.replace(/\bdr\.?$/, "drive");
      s = s.replace(/\bln\.?$/, "lane");
      s = s.replace(/\bct\.?$/, "court");
      s = s.replace(/\bpkwy\.?$/, "parkway");
      s = s.replace(/\bpl\.?$/, "place");
      s = s.replace(/\btrl\.?$/, "trail");
      s = s.replace(/\bcir\.?$/, "circle");
      s = s.replace(/\bway\.?$/, "way");
      s = s.replace(/\bterr\.?$/, "terrace");
      s = s.replace(/\s+/g, " ");
      return s;
    }

    // Main function
    async function main() {
      const loadingEl = document.getElementById("loading");
      const listEl = document.getElementById("list");

      try {
        loadingEl.textContent = "Loading Ann Arbor city boundary...";

        // Fetch boundary relation + members
        const boundaryData = await overpassQuery(boundaryQuery);

        // Extract polygon geometry latlngs arrays
        const waysLatLngs = osmGeometryToLatLngs(boundaryData.elements);

        cityPolygonLatLngs = flattenPolygon(waysLatLngs);

        // Initialize map centered on Ann Arbor
        map = L.map("map").setView([42.28, -83.74], 13);
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          maxZoom: 19,
          attribution: "© OpenStreetMap contributors",
        }).addTo(map);

        // Draw city boundary polygon
        cityBoundaryLayer = L.polygon(cityPolygonLatLngs, {
          color: "#0077cc",
          weight: 3,
          fillOpacity: 0.1,
        }).addTo(map);
        map.fitBounds(cityBoundaryLayer.getBounds());

        loadingEl.textContent = "Loading streets inside Ann Arbor city limits...";

        // Build polygon string for Overpass (format: "lat lon lat lon ...")
        const polygonStr = cityPolygonLatLngs
          .map((ll) => ll[0] + " " + ll[1])
          .join(" ");

        // Overpass query for named highways fully inside polygon
        // "way( poly: "lat lon ..." )[highway][name];"
        const streetsQuery = `
          [out:json][timeout:60];
          way( poly: "${polygonStr}" )[highway][name];
          out tags;
        `;

        const streetData = await overpassQuery(streetsQuery);

        // Extract unique normalized street names
        const streetNamesSet = new Set();
        streetData.elements.forEach((e) => {
          if (e.tags && e.tags.name) {
            streetNamesSet.add(normalizeName(e.tags.name));
          }
        });

        const streetNames = Array.from(streetNamesSet).sort();

        loadingEl.style.display = "none";

        // Display street names as list
        listEl.innerHTML =
          "<h2>Ann Arbor Streets (" +
          streetNames.length +
          ")</h2>" +
          "<ul>" +
          streetNames
            .map(
              (n) =>
                `<li style="padding:3px 0; border-bottom:1px solid #ddd;">${n
                  .split(" ")
                  .map(
                    (w) => w.charAt(0).toUpperCase() + w.slice(1)
                  )
                  .join(" ")}</li>`
            )
            .join("") +
          "</ul>";
      } catch (e) {
        loadingEl.textContent = "Error loading data: " + e.message;
      }
    }

    main();
  </script>
</body>
</html>