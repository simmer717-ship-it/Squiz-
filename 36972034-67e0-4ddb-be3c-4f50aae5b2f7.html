<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
	<title></title>
	<meta name="generator" content="LibreOffice 24.8.1.2 (Linux)"/>
	<meta name="created" content="00:00:00"/>
	<meta name="changed" content="00:00:00"/>
	<style type="text/css">
		@page { size: 8.27in 11.69in; margin: 0.79in }
		p { line-height: 115%; margin-bottom: 0.1in; background: transparent }
		pre { background: transparent }
		pre.western { font-family: "Liberation Mono", monospace; font-size: 10pt }
		pre.cjk { font-family: "NSimSun", monospace; font-size: 10pt }
		pre.ctl { font-family: "Liberation Mono", monospace; font-size: 10pt }
	</style>
</head>
<body lang="en-US" link="#000080" vlink="#800000" dir="ltr"><pre class="western">&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot; /&gt;
  &lt;title&gt;Ann Arbor Streets List&lt;/title&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot; /&gt;
  &lt;link
    rel=&quot;stylesheet&quot;
    href=&quot;https://unpkg.com/leaflet@1.9.4/dist/leaflet.css&quot;
  /&gt;
  &lt;style&gt;
    html,
    body,
    #map {
      height: 40vh;
      margin: 0;
      padding: 0;
    }
    #list {
      height: 55vh;
      overflow-y: auto;
      padding: 10px;
      font-family: system-ui, -apple-system, &quot;Segoe UI&quot;, Roboto,
        &quot;Helvetica Neue&quot;, Arial;
      background: #fafafa;
      border-top: 1px solid #ccc;
    }
    #loading {
      padding: 10px;
      font-family: system-ui, -apple-system, &quot;Segoe UI&quot;, Roboto,
        &quot;Helvetica Neue&quot;, Arial;
      color: #555;
    }
    h2 {
      margin: 5px 0;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;map&quot;&gt;&lt;/div&gt;
  &lt;div id=&quot;loading&quot;&gt;Loading Ann Arbor city boundary and streets...&lt;/div&gt;
  &lt;div id=&quot;list&quot;&gt;&lt;/div&gt;

  &lt;script src=&quot;https://unpkg.com/leaflet@1.9.4/dist/leaflet.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    // Overpass API endpoint
    const OVERPASS_URL = &quot;https://overpass-api.de/api/interpreter&quot;;

    // Function to fetch JSON from Overpass API with given query
    async function overpassQuery(query) {
      const response = await fetch(OVERPASS_URL, {
        method: &quot;POST&quot;,
        body: query,
        headers: { &quot;Content-Type&quot;: &quot;text/plain&quot; },
      });
      if (!response.ok) throw new Error(&quot;Overpass API error&quot;);
      return response.json();
    }

    // Step 1: Fetch Ann Arbor city boundary polygon (relation with name=Ann Arbor and admin_level=8)
    const boundaryQuery = `
      [out:json][timeout:25];
      relation[&quot;boundary&quot;=&quot;administrative&quot;][&quot;admin_level&quot;=&quot;8&quot;][&quot;name&quot;=&quot;Ann Arbor&quot;]-&gt;.rel;
      (.rel;&gt;;);
      out body;
    `;

    // Globals
    let cityPolygonLatLngs = [];
    let map;
    let cityBoundaryLayer;

    // Utility: Convert OSM geometry to Leaflet LatLng arrays
    function osmGeometryToLatLngs(elements) {
      const nodes = {};
      elements
        .filter((e) =&gt; e.type === &quot;node&quot;)
        .forEach((n) =&gt; {
          nodes[n.id] = [n.lat, n.lon];
        });

      // A relation's geometry is in its member ways
      // We'll build polygons from member ways, sorted by sequence
      const ways = elements.filter((e) =&gt; e.type === &quot;way&quot;);

      // Each way is an array of node ids forming a polyline
      // Build an array of latlng arrays for each way
      return ways.map((way) =&gt; way.geometry.map((p) =&gt; [p.lat, p.lon]));
    }

    // Step 2: Use polygon to fetch all streets fully inside it (highway ways with name)
    function buildPolygonString(latlngs) {
      // Format: lat lon pairs separated by spaces, polygon string for Overpass
      return latlngs.map((ll) =&gt; ll[0] + &quot; &quot; + ll[1]).join(&quot; &quot;);
    }

    // Because Ann Arbor relation geometry comes as multiple ways forming the boundary,
    // we need to stitch these together into a single polygon.
    // For simplicity, we’ll just flatten all ways into one long polygon.
    // This might not be perfect for complex boundaries but is fine here.

    // Function to flatten multi-line polygon geometry into a simple polygon (may self-intersect)
    function flattenPolygon(waysLatLngs) {
      let flat = [];
      waysLatLngs.forEach((way) =&gt; {
        flat.push(...way);
      });
      // Close polygon if needed
      if (
        flat.length &amp;&amp;
        (flat[0][0] !== flat[flat.length - 1][0] ||
          flat[0][1] !== flat[flat.length - 1][1])
      ) {
        flat.push(flat[0]);
      }
      return flat;
    }

    // Normalize street name (remove abbreviations and punctuation)
    function normalizeName(s) {
      if (!s) return &quot;&quot;;
      s = s.toLowerCase().trim();
      s = s.replace(/[.,'&quot;]/g, &quot;&quot;);
      // Expand common abbreviations (St, Rd, Ave, Blvd, Dr, Ln, Ct, Pkwy)
      s = s.replace(/\bst\.?$/, &quot;street&quot;);
      s = s.replace(/\brd\.?$/, &quot;road&quot;);
      s = s.replace(/\bave\.?$/, &quot;avenue&quot;);
      s = s.replace(/\bblvd\.?$/, &quot;boulevard&quot;);
      s = s.replace(/\bdr\.?$/, &quot;drive&quot;);
      s = s.replace(/\bln\.?$/, &quot;lane&quot;);
      s = s.replace(/\bct\.?$/, &quot;court&quot;);
      s = s.replace(/\bpkwy\.?$/, &quot;parkway&quot;);
      s = s.replace(/\bpl\.?$/, &quot;place&quot;);
      s = s.replace(/\btrl\.?$/, &quot;trail&quot;);
      s = s.replace(/\bcir\.?$/, &quot;circle&quot;);
      s = s.replace(/\bway\.?$/, &quot;way&quot;);
      s = s.replace(/\bterr\.?$/, &quot;terrace&quot;);
      s = s.replace(/\s+/g, &quot; &quot;);
      return s;
    }

    // Main function
    async function main() {
      const loadingEl = document.getElementById(&quot;loading&quot;);
      const listEl = document.getElementById(&quot;list&quot;);

      try {
        loadingEl.textContent = &quot;Loading Ann Arbor city boundary...&quot;;

        // Fetch boundary relation + members
        const boundaryData = await overpassQuery(boundaryQuery);

        // Extract polygon geometry latlngs arrays
        const waysLatLngs = osmGeometryToLatLngs(boundaryData.elements);

        cityPolygonLatLngs = flattenPolygon(waysLatLngs);

        // Initialize map centered on Ann Arbor
        map = L.map(&quot;map&quot;).setView([42.28, -83.74], 13);
        L.tileLayer(&quot;https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png&quot;, {
          maxZoom: 19,
          attribution: &quot;© OpenStreetMap contributors&quot;,
        }).addTo(map);

        // Draw city boundary polygon
        cityBoundaryLayer = L.polygon(cityPolygonLatLngs, {
          color: &quot;#0077cc&quot;,
          weight: 3,
          fillOpacity: 0.1,
        }).addTo(map);
        map.fitBounds(cityBoundaryLayer.getBounds());

        loadingEl.textContent = &quot;Loading streets inside Ann Arbor city limits...&quot;;

        // Build polygon string for Overpass (format: &quot;lat lon lat lon ...&quot;)
        const polygonStr = cityPolygonLatLngs
          .map((ll) =&gt; ll[0] + &quot; &quot; + ll[1])
          .join(&quot; &quot;);

        // Overpass query for named highways fully inside polygon
        // &quot;way( poly: &quot;lat lon ...&quot; )[highway][name];&quot;
        const streetsQuery = `
          [out:json][timeout:60];
          way( poly: &quot;${polygonStr}&quot; )[highway][name];
          out tags;
        `;

        const streetData = await overpassQuery(streetsQuery);

        // Extract unique normalized street names
        const streetNamesSet = new Set();
        streetData.elements.forEach((e) =&gt; {
          if (e.tags &amp;&amp; e.tags.name) {
            streetNamesSet.add(normalizeName(e.tags.name));
          }
        });

        const streetNames = Array.from(streetNamesSet).sort();

        loadingEl.style.display = &quot;none&quot;;

        // Display street names as list
        listEl.innerHTML =
          &quot;&lt;h2&gt;Ann Arbor Streets (&quot; +
          streetNames.length +
          &quot;)&lt;/h2&gt;&quot; +
          &quot;&lt;ul&gt;&quot; +
          streetNames
            .map(
              (n) =&gt;
                `&lt;li style=&quot;padding:3px 0; border-bottom:1px solid #ddd;&quot;&gt;${n
                  .split(&quot; &quot;)
                  .map(
                    (w) =&gt; w.charAt(0).toUpperCase() + w.slice(1)
                  )
                  .join(&quot; &quot;)}&lt;/li&gt;`
            )
            .join(&quot;&quot;) +
          &quot;&lt;/ul&gt;&quot;;
      } catch (e) {
        loadingEl.textContent = &quot;Error loading data: &quot; + e.message;
      }
    }

    main();
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
</body>
</html>